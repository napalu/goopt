package translations

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/napalu/goopt/v2"
	"github.com/napalu/goopt/v2/cmd/goopt-i18n-gen/messages"
	"github.com/napalu/goopt/v2/cmd/goopt-i18n-gen/options"
	"github.com/napalu/goopt/v2/i18n"
	"golang.org/x/text/language"
)

const localePackageTemplate = `// Code generated by goopt-i18n-gen. DO NOT EDIT.

package {{.PackageName}}

import "golang.org/x/text/language"

// Tag is the language tag for {{.LanguageNameFull}}
var Tag = {{.LanguageTagCode}}

// SystemTranslations contains all goopt system messages in {{.LanguageNameFull}}
const SystemTranslations = {{.BacktickJSON}}

// Metadata
const (
	LanguageCode = "{{.LanguageCode}}"
	LanguageName = "{{.LanguageNameFull}}"
	Direction    = "{{.Direction}}"
)
`

// GenerateLocales generates Go packages from locale JSON files
func GenerateLocales(parser *goopt.Parser, cmd *goopt.Command) error {
	cfg, ok := goopt.GetStructCtxAs[*options.AppConfig](parser)
	if !ok {
		parser.GetUserBundle().T(messages.Keys.AppError.FailedToGetConfig)
	}

	tr := cfg.TR
	opt := &cfg.GenerateLocales

	// Load all locale files
	locales, err := loadLocaleFiles(cfg.Input, tr)
	if err != nil {
		return err
	}

	// Process each locale
	for _, locale := range locales {
		if err := generateLocalePackage(locale, opt, tr); err != nil {
			return fmt.Errorf(tr.T(messages.Keys.AppError.FailedToGeneratePackage, locale.Code, err))
		}
	}

	if !opt.DryRun {
		fmt.Printf("Successfully generated %d locale packages\n", len(locales))
	}

	return nil
}

type localeData struct {
	Code         string
	Lang         language.Tag
	Translations map[string]string
}

func loadLocaleFiles(patterns []string, tr i18n.Translator) ([]localeData, error) {
	var locales []localeData
	seen := make(map[string]bool)

	for _, pattern := range patterns {
		files, err := filepath.Glob(pattern)
		if err != nil {
			return nil, fmt.Errorf(tr.T(messages.Keys.AppError.InvalidPattern, pattern, err))
		}

		for _, file := range files {
			// Extract language code from filename (e.g., "es.json" -> "es")
			base := filepath.Base(file)
			ext := filepath.Ext(base)
			if ext != ".json" {
				continue
			}

			langCode := strings.TrimSuffix(base, ext)
			if seen[langCode] {
				continue
			}
			seen[langCode] = true

			// Read and parse JSON
			data, err := os.ReadFile(file)
			if err != nil {
				return nil, fmt.Errorf(tr.T(messages.Keys.AppError.FailedToReadFile, file, err))
			}

			var translations map[string]string
			if err := json.Unmarshal(data, &translations); err != nil {
				return nil, fmt.Errorf(tr.T(messages.Keys.AppError.FailedToParseFile, file, err))
			}

			// Parse language tag
			lang, err := language.Parse(langCode)
			if err != nil {
				// Try with common mappings
				lang = mapCommonLanguageCodes(langCode)
				if lang == language.Und {
					return nil, fmt.Errorf(tr.T(messages.Keys.AppError.UnknownLanguageCode, langCode, file))
				}
			}

			locales = append(locales, localeData{
				Code:         langCode,
				Lang:         lang,
				Translations: translations,
			})
		}
	}

	// Sort by language code for consistent output
	sort.Slice(locales, func(i, j int) bool {
		return locales[i].Code < locales[j].Code
	})

	return locales, nil
}

func generateLocalePackage(locale localeData, opt *options.GenerateLocalesCmd, tr i18n.Translator) error {
	// Create package directory
	packageDir := filepath.Join(opt.Output, locale.Code)
	if !opt.DryRun {
		if err := os.MkdirAll(packageDir, 0755); err != nil {
			return fmt.Errorf(tr.T(messages.Keys.AppError.FailedToCreateDirectory, err))
		}
	}

	// Generate package content
	content, err := generatePackageContent(locale, opt.PackageBase)
	if err != nil {
		return err
	}

	// Write file
	outputFile := filepath.Join(packageDir, locale.Code+"_gen.go")
	if opt.DryRun {
		fmt.Printf("Would generate: %s\n", outputFile)
		fmt.Println(content)
		fmt.Println()
	} else {
		if err := os.WriteFile(outputFile, []byte(content), 0644); err != nil {
			return fmt.Errorf(tr.T(messages.Keys.AppError.FailedToWriteFile, err))
		}
		fmt.Printf("Generated: %s\n", outputFile)
	}

	return nil
}

func generatePackageContent(locale localeData, packageBase string) (string, error) {
	// Marshal translations back to JSON with proper formatting
	jsonBytes, err := json.MarshalIndent(locale.Translations, "    ", "    ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal translations: %w", err)
	}

	// Prepare template data
	data := struct {
		PackageName      string
		LanguageCode     string
		LanguageNameFull string
		LanguageTagCode  string
		Direction        string
		BacktickJSON     string
	}{
		PackageName:      locale.Code,
		LanguageCode:     locale.Code,
		LanguageNameFull: getLanguageFullName(locale.Lang),
		LanguageTagCode:  getLanguageTagCode(locale.Lang),
		Direction:        getLanguageDirection(locale.Lang),
		BacktickJSON:     "`" + string(jsonBytes) + "`",
	}

	// Execute template
	tmpl, err := template.New("locale").Parse(localePackageTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.String(), nil
}

func getLanguageFullName(tag language.Tag) string {
	// Map common language tags to their English names
	switch tag {
	case language.English:
		return "English"
	case language.German:
		return "German"
	case language.French:
		return "French"
	case language.Spanish:
		return "Spanish"
	case language.Japanese:
		return "Japanese"
	case language.Arabic:
		return "Arabic"
	case language.Hebrew:
		return "Hebrew"
	case language.Portuguese:
		return "Portuguese"
	case language.Russian:
		return "Russian"
	case language.Chinese:
		return "Chinese"
	case language.Korean:
		return "Korean"
	case language.Italian:
		return "Italian"
	case language.Dutch:
		return "Dutch"
	default:
		// For other languages, return the tag string
		return tag.String()
	}
}

func getLanguageTagCode(tag language.Tag) string {
	// Map to language package constants where available
	switch tag {
	case language.English:
		return "language.English"
	case language.German:
		return "language.German"
	case language.French:
		return "language.French"
	case language.Spanish:
		return "language.Spanish"
	case language.Japanese:
		return "language.Japanese"
	case language.Arabic:
		return "language.Arabic"
	case language.Hebrew:
		return "language.Hebrew"
	case language.Portuguese:
		return "language.Portuguese"
	case language.Russian:
		return "language.Russian"
	case language.Chinese:
		return "language.Chinese"
	case language.Korean:
		return "language.Korean"
	case language.Italian:
		return "language.Italian"
	case language.Dutch:
		return "language.Dutch"
	default:
		// For other languages, use MustParse
		return fmt.Sprintf("language.MustParse(%q)", tag.String())
	}
}

func getLanguageDirection(tag language.Tag) string {
	// Check if it's an RTL language
	base, _ := tag.Base()
	switch base.String() {
	case "ar", "he", "fa", "ur":
		return "rtl"
	default:
		return "ltr"
	}
}

func mapCommonLanguageCodes(code string) language.Tag {
	// Map common language codes that might not parse directly
	switch code {
	case "en":
		return language.English
	case "de":
		return language.German
	case "fr":
		return language.French
	case "es":
		return language.Spanish
	case "ja":
		return language.Japanese
	case "ar":
		return language.Arabic
	case "he":
		return language.Hebrew
	case "pt":
		return language.Portuguese
	case "ru":
		return language.Russian
	case "zh":
		return language.Chinese
	case "ko":
		return language.Korean
	case "it":
		return language.Italian
	case "nl":
		return language.Dutch
	default:
		return language.Und
	}
}
